{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Web App Tutorial","text":"<ul> <li>Gihub Homepage from Markdown</li> <li>Simple App</li> <li>Tools</li> </ul>"},{"location":"github_md/","title":"Github from Markdown","text":"<p>Here's the updated version with the structure preserved and language improvements:</p>"},{"location":"github_md/#creating-a-github-page-for-your-markdown-documents-using-mkdocs","title":"Creating a GitHub Page for Your Markdown Documents Using MkDocs","text":"<p>Making a GitHub Page for your markdown documents is easy with <code>mkdocs</code>. Essentially, it involves moving all markdown documents to the <code>docs</code> folder and creating an <code>mkdocs.yml</code> file (see below). The full list of required commands is as follows:</p> <pre><code>pip install mkdocs\n\n# This command is optional. It simply creates the docs folder with index.md and mkdocs.yml file, which can be done manually.\nmkdocs new .\n\n# Serve locally at http://127.0.0.1:8000 to check that everything is running smoothly.\nmkdocs serve\n\n# Deploy to GitHub Pages. This should be run after every change to markdown files in the docs folder or mkdocs.yml. You can automate this with a GitHub workflow (see below).\nmkdocs gh-deploy\n</code></pre> <p>Move all markdown files to the <code>docs</code> folder and create the <code>mkdocs.yml</code> file in the root of the repository. If you have a <code>README.md</code> file, it can remain as is, but you should remove the <code>index.md</code> file if it is automatically created by <code>mkdocs new .</code>. Alternatively, you can rename <code>README.md</code> to <code>index.md</code>. Running <code>mkdocs new .</code> will automatically create the <code>mkdocs.yml</code> file and the <code>docs</code> folder with an <code>index.md</code> file.</p>"},{"location":"github_md/#example-repository-structure","title":"Example Repository Structure","text":"<pre><code>.\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 README.md\n\u2502   \u251c\u2500\u2500 cheatsheet.md\n\u2502   \u2514\u2500\u2500 Tutorial/\n\u2502       \u2514\u2500\u2500 iframe.md\n\u251c\u2500\u2500 mkdocs.yml\n</code></pre>"},{"location":"github_md/#configuring-mkdocsyml","title":"Configuring mkdocs.yml","text":"<p>In <code>mkdocs.yml</code>, add the following configuration. If you're using the <code>material</code> theme, it should be installed with <code>pip install mkdocs-material</code>.</p> <pre><code>site_name: \"Web App Tutorial\"\nnav:\n  - README.md # or index.md or remove it.\n  - Cheatsheet: cheatsheet.md\n  - Tutorial:\n      - Iframe: tutorial/iframe.md\ntheme:\n  name: material  # Use 'readthedocs' or other themes if preferred\n</code></pre>"},{"location":"github_md/#github-workflow","title":"GitHub Workflow","text":"<p>Without a workflow, you need to run <code>mkdocs gh-deploy</code> each time you change the documents. To automate this, create a workflow file at <code>.github/workflows/deploy.yml</code>.</p> <pre><code>name: Deploy MkDocs Site\n\non:\n  push:\n    paths:\n      - 'docs/**'\n      - 'mkdocs.yml'\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.x'\n\n    - name: Install dependencies\n      run: |\n        pip install mkdocs\n        pip install mkdocs-material  # Only if using the Material theme\n\n    - name: Deploy to GitHub Pages\n      run: |\n        mkdocs gh-deploy --force\n</code></pre>"},{"location":"github_md/#workflow-for-each-push","title":"Workflow for Each Push","text":"<p>If you want the workflow to trigger on every push, regardless of whether <code>docs/</code> or <code>mkdocs.yml</code> is changed, modify the <code>on:</code> section:</p> <pre><code>on:\n  push:\n    branches:\n      - main\n</code></pre> <p>This replaces the following:</p> <pre><code>on:\n  push:\n    paths:\n      - 'docs/**'\n      - 'mkdocs.yml'\n</code></pre>"},{"location":"github_md/#no-separate-commit-for-workflow","title":"No Separate Commit for Workflow","text":"<p>You don't need a separate commit for rendered HTML, as <code>mkdocs gh-deploy</code> handles it for you.</p> <pre><code>    - name: Commit and Push Rendered HTML\n      run: |\n        git config --local user.email \"fkariminejadasl@gmail.com\"\n        git config --local user.name \"Fatemeh Karimi Nejadasl\"\n        git add -f *.html\n        git commit -m \"Generate HTML\" -a || echo \"No changes to commit\"\n        git push\n</code></pre>"},{"location":"github_md/#when-you-might-need-to-explicitly-use-github_token","title":"When You Might Need to Explicitly Use <code>GITHUB_TOKEN</code>","text":"<p>You only need to explicitly reference <code>GITHUB_TOKEN</code> if:</p> <ul> <li>You're passing it to a custom script or command that requires it.</li> <li>You're passing it to a different environment or third-party service that needs authentication.</li> </ul> <p>In most basic workflows, like deploying with <code>mkdocs gh-deploy</code>, GitHub handles <code>GITHUB_TOKEN</code> automatically. This is why it works without setting it explicitly.</p> <pre><code>    - name: Deploy to GitHub Pages\n      run: |\n        mkdocs gh-deploy --force\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre>"},{"location":"github_md/#mkdocs-build-vs-mkdocs-gh-deploy","title":"<code>mkdocs build</code> vs. <code>mkdocs gh-deploy</code>","text":"<ul> <li><code>mkdocs build</code>: Used to build the documentation site locally. After running this, the generated site is placed in a directory called <code>site/</code> within your project folder.</li> <li><code>mkdocs gh-deploy</code>: Builds the site (similar to <code>mkdocs build</code>), but also pushes the generated files to the <code>gh-pages</code> branch of your GitHub repository, which is used by GitHub Pages to serve the site.</li> </ul>"},{"location":"github_md/#when-to-use-each","title":"When to Use Each","text":"<ul> <li>Use <code>mkdocs gh-deploy</code> when deploying to GitHub Pages.</li> <li>Use <code>mkdocs build</code> when generating the site files locally for testing or if you're deploying the files manually to another server.</li> </ul>"},{"location":"github_md/#using-a-custom-domain-cname","title":"Using a Custom Domain (CNAME)","text":"<p>If you'd like to use a custom domain (e.g., <code>www.yourdomain.com</code>) for your GitHub Pages site, you can configure it with a CNAME file.</p>"},{"location":"github_md/#steps-for-using-a-cname-with-github-pages","title":"Steps for Using a CNAME with GitHub Pages","text":"<ol> <li>Create a CNAME File:</li> <li>In your repository (inside the <code>docs/</code> folder or the root, depending on your project structure), create a file called <code>CNAME</code> (without an extension).</li> <li>Inside the <code>CNAME</code> file, write your custom domain name (e.g., <code>www.yourdomain.com</code>).</li> </ol> <p>Example content of <code>CNAME</code>:    <code>www.yourdomain.com</code></p> <ol> <li>GitHub Pages Settings:</li> <li>Go to your repository\u2019s settings.</li> <li>Scroll down to the \"GitHub Pages\" section.</li> <li> <p>In the Custom domain field, enter your domain (e.g., <code>www.yourdomain.com</code>).</p> </li> <li> <p>DNS Configuration:</p> </li> <li>In your domain registrar's settings, create a CNAME record that points your custom domain (e.g., <code>www.yourdomain.com</code>) to <code>&lt;your-github-username&gt;.github.io</code>.</li> <li>Example of CNAME record in DNS settings:<ul> <li>Name: <code>www</code></li> <li>Type: CNAME</li> <li>Value: <code>&lt;your-github-username&gt;.github.io</code></li> </ul> </li> </ol> <p>Once the DNS settings propagate (which can take a few hours), your GitHub Pages site will be accessible via your custom domain.</p>"},{"location":"github_md/#recap-of-steps-for-deploying-mkdocs-with-github-pages","title":"Recap of Steps for Deploying MkDocs with GitHub Pages","text":"<ol> <li>Run <code>mkdocs gh-deploy</code> to build and deploy your documentation:</li> </ol> <pre><code>mkdocs gh-deploy\n</code></pre> <ol> <li> <p>If you're using a custom domain, create a <code>CNAME</code> file containing your domain name (e.g., <code>www.yourdomain.com</code>) and configure your domain\u2019s DNS settings.</p> </li> <li> <p>GitHub Pages will now serve your MkDocs site at either <code>https://&lt;your-username&gt;.github.io/&lt;repository-name&gt;</code> or your custom domain, if configured.</p> </li> </ol>"},{"location":"github_md/#type-formula","title":"Type formula","text":"<ol> <li>Add in <code>mkdocs.yaml</code></li> </ol> <pre><code>markdown_extensions:\n  - pymdownx.arithmatex:\n      generic: true\nextra_javascript:\n  - https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js\n</code></pre> <ol> <li>Add in <code>pip install pymdown-extensions</code> in <code>.github\\workflows\\deploy.md</code>:</li> </ol> <pre><code>    - name: Install dependencies\n      run: |\n        pip install mkdocs\n        pip install mkdocs-material\n        pip install pymdown-extensions # New\n</code></pre> <p>Type formulas as in Latex, e.g. inline \\(\\omega\\) with <code>$\\omega</code> or as a separate line with <code>$$x^2 + y^2 = 1$$</code> or <code>\\[x^2 + y^2 = 1\\]</code>:</p> \\[x^2 + y^2 = 1\\]"},{"location":"simple_app/","title":"Simple App","text":"<p>This app open image <code>project_directory/static/image.jpg</code> and user draw bounding boxes. The result is save in a <code>bounding_boxes.json</code> file. This app is made with a help of chatGPT 40, with multiple prompts.</p> <pre><code>project_directory\n    /static\n        image.jpg\n    /templates\n        index.html\n    app.py\n</code></pre> <p>index.html:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Draw Multiple Bounding Boxes&lt;/title&gt;\n    &lt;style&gt;\n        canvas {\n            border: 1px solid black;\n            display: block;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Draw Multiple Bounding Boxes on the Image&lt;/h1&gt;\n\n    &lt;!-- Canvas where the image and bounding box will be drawn --&gt;\n    &lt;canvas id=\"imageCanvas\"&gt;&lt;/canvas&gt;\n\n    &lt;!-- Download button for bounding boxes --&gt;\n    &lt;button id=\"downloadButton\" style=\"display:none;\"&gt;Download Bounding Box Data&lt;/button&gt;\n\n    &lt;script&gt;\n        const imageCanvas = document.getElementById('imageCanvas');\n        const ctx = imageCanvas.getContext('2d');\n        const img = new Image();\n        img.src = \"{{ url_for('static', filename='image.jpg') }}\";  // Load image\n\n        let startX, startY, isDrawing = false;\n        const boundingBoxes = [];  // Array to store multiple bounding boxes\n\n        // When the image is loaded, set the canvas size to the image size and draw the image\n        img.onload = function() {\n            imageCanvas.width = img.width;\n            imageCanvas.height = img.height;\n            ctx.drawImage(img, 0, 0);\n        };\n\n        // Function to redraw all bounding boxes\n        function redrawCanvas() {\n            ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);\n            ctx.drawImage(img, 0, 0);\n\n            // Redraw all bounding boxes\n            boundingBoxes.forEach(box =&gt; {\n                ctx.beginPath();\n                ctx.rect(box.startX, box.startY, box.width, box.height);\n                ctx.strokeStyle = 'red';\n                ctx.lineWidth = 2;\n                ctx.stroke();\n            });\n        }\n\n        // Mouse down event to start drawing the bounding box\n        imageCanvas.addEventListener('mousedown', function(e) {\n            startX = e.offsetX;\n            startY = e.offsetY;\n            isDrawing = true;\n        });\n\n        // Mouse move event to draw the bounding box dynamically as the user moves the mouse\n        imageCanvas.addEventListener('mousemove', function(e) {\n            if (isDrawing) {\n                const currentX = e.offsetX;\n                const currentY = e.offsetY;\n                const width = currentX - startX;\n                const height = currentY - startY;\n\n                // Redraw the canvas and display the new bounding box being drawn\n                redrawCanvas();\n                ctx.beginPath();\n                ctx.rect(startX, startY, width, height);\n                ctx.strokeStyle = 'blue';  // Use a different color while drawing\n                ctx.lineWidth = 2;\n                ctx.stroke();\n            }\n        });\n\n        // Mouse up event to finalize the bounding box drawing\n        imageCanvas.addEventListener('mouseup', function(e) {\n            isDrawing = false;\n\n            // Capture the final bounding box dimensions\n            const currentX = e.offsetX;\n            const currentY = e.offsetY;\n            const width = currentX - startX;\n            const height = currentY - startY;\n\n            // Save the bounding box data locally\n            boundingBoxes.push({ startX, startY, width, height });\n\n            // Send the bounding box data to the server via AJAX\n            sendBoundingBoxData(startX, startY, width, height);\n\n            // Redraw the canvas with the new bounding box included\n            redrawCanvas();\n        });\n\n        // Function to send bounding box data to the server\n        function sendBoundingBoxData(x, y, width, height) {\n            const data = {\n                startX: x,\n                startY: y,\n                width: width,\n                height: height\n            };\n\n            fetch('/save_bounding_box', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(data)\n            })\n            .then(response =&gt; response.json())\n            .then(data =&gt; {\n                console.log('Bounding box saved:', data);\n                // Show the download button after the bounding box is saved\n                document.getElementById('downloadButton').style.display = 'block';\n            })\n            .catch((error) =&gt; {\n                console.error('Error:', error);\n            });\n        }\n\n        // Add event listener to download button\n        document.getElementById('downloadButton').addEventListener('click', function() {\n            window.location.href = '/download_bounding_boxes';\n        });\n\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>app.py</p> <pre><code>from flask import Flask, request, jsonify, render_template, send_file\nimport os\nimport json\n\napp = Flask(__name__)\n\n# Path to save the bounding box data\nBOUNDING_BOX_FILE = 'bounding_boxes.json'\n\n@app.route('/')\ndef home():\n    return render_template('index.html')\n\n# Route to handle saving the bounding box data\n@app.route('/save_bounding_box', methods=['POST'])\ndef save_bounding_box():\n    data = request.get_json()  # Get the JSON data sent from the frontend\n\n    # Bounding box data structure\n    bounding_box_data = {\n        \"startX\": data['startX'],\n        \"startY\": data['startY'],\n        \"width\": data['width'],\n        \"height\": data['height']\n    }\n\n    # Load existing bounding boxes if they exist, otherwise create an empty list\n    if os.path.exists(BOUNDING_BOX_FILE):\n        with open(BOUNDING_BOX_FILE, 'r') as f:\n            boxes = json.load(f)\n    else:\n        boxes = []\n\n    # Add the new bounding box to the list and save to file\n    boxes.append(bounding_box_data)\n    with open(BOUNDING_BOX_FILE, 'w') as f:\n        json.dump(boxes, f)\n\n    print(f\"Bounding Box saved: {bounding_box_data}\")\n\n    # Respond back to the frontend with success\n    return jsonify({\"message\": \"Bounding box saved successfully\"}), 200\n\n# Route to download the bounding box data as a file\n@app.route('/download_bounding_boxes', methods=['GET'])\ndef download_bounding_boxes():\n    if os.path.exists(BOUNDING_BOX_FILE):\n        return send_file(BOUNDING_BOX_FILE, as_attachment=True)\n    else:\n        return jsonify({\"message\": \"No bounding box data available\"}), 404\n\nif __name__ == '__main__':\n    app.run(debug=True)\n</code></pre> <p>Requirement: </p> <pre><code>pip install Flask\n</code></pre> <p>Run the app by <code>python app.py</code>. </p> <p>Result is <code>bounding_boxes.json</code>. E.g.: <code>[{\"startX\": 551, \"startY\": 66, \"width\": 384, \"height\": 543}, {\"startX\": 37, \"startY\": 106, \"width\": 515, \"height\": 523}]</code></p>"},{"location":"tools/","title":"Tools","text":"<p>For people with little or no knowledge of app development, AI is a useful tool. Depending on your expertise, AI can be used as part of the app development process, or for complete app development using Vibe Coding.</p> <p>The web app can be as simple as using Gradio, a bit more complex like Streamlit, FastAPI + Docker, Dash (Plotly), or Shiny, and deployed on Hugging Face Spaces for free on the minimum machine.</p> <p>The app components can be databases, authentication, payment gateways (e.g., Stripe, Polar), webhooks, deployment (Vercel, Linode (Akamai)).</p>"},{"location":"tools/#vibe-coding","title":"Vibe Coding","text":"<p>Vibe Coding means that 100% of the code is generated by AI.</p> <p>Check security vulnerability checklists before deployment:</p> <ul> <li>https://x.com/jackfriks/status/1902686165158805839</li> <li>https://x.com/tedx_ai/status/1902375510174314783</li> </ul> <p>The tools and definitions presented below will most likely be outdated soon.</p>"},{"location":"tools/#examples","title":"Examples:","text":"<ul> <li>Using API by Copy &amp; Pasting: ChatGPT, Claude, Grok, Perplexity, DeepSeek</li> <li>AI-Enhanced IDEs &amp; Dev Platforms: Cursor, Windsurf, Replit, Cline, v0 (Vercel), Devika, GitHub Copilot (Microsoft), Gemini Code Assist (Google)</li> <li>Agentic AI Developer Agents &amp; APIs: GitHub Spark, Codex (OpenAI), Claude Code (Anthropic), Gemini CLI (Google), Firebase Studio (Google), Devin (Cognition Labs), Aider, Kiro (Amazon)</li> <li>Fully web-based platforms: Lovable (React), Tempo AI, Bolt.new, Databutton (Python + React)</li> </ul>"},{"location":"tools/#definitions","title":"Definitions","text":"<ul> <li>AI-Enhanced IDEs &amp; Dev Platforms: Code-first environments\u2014either forks of VS Code or integrated development platforms\u2014that embed AI directly into your editor or workspace, letting you write, refactor, and run code via natural-language instructions.</li> <li>Agentic AI Developer Agents &amp; APIs: Standalone \u201cagent\u201d tools and LLM-powered services\u2014accessed via CLI, API, or cloud console\u2014that can plan features, implement code changes, run tests, and even deploy pull requests.</li> <li>Fully web-based platforms: No-install, browser-only services that let non-technical users\u2014and developers\u2014prototype and deploy full-stack apps via visual UIs and text prompts.</li> </ul>"},{"location":"tools/#deployment","title":"Deployment","text":"<p>Hugging Face, Google Colab, University infrastructure (SURF Research Cloud), Vercel, Linode</p>"},{"location":"tools/#tools","title":"Tools","text":"<ul> <li>Frontend (Client-Side): HTML/CSS/JS, React (JavaScript)</li> <li>Backend (Server-Side): Python (Django; FastAPI + Fly.io style), Node.js (JavaScript)</li> <li>Design: Figma; Bootstrap templates and themes</li> <li>Full-stack front- or back-end: Next.js</li> </ul>"},{"location":"tools/#references","title":"References","text":"<ul> <li>Andrej Karpathy: https://karpathy.bearblog.dev/vibe-coding-menugen</li> <li>Pieter Levels (Levelsio): https://levels.io/how-i-build-my-minimum-viable-products</li> </ul>"},{"location":"tutorial/iframe/","title":"Iframe","text":"<p>Some dummy info.</p> <p>check the github workflow</p>"}]}